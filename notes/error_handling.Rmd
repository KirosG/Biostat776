% Handling Errors and Conditions
% Biostatistics 140.776
%

```{r,include=FALSE}
knitr::opts_chunk$set(comment = NA, collapse = TRUE)
```

# Conditions

R has a few types of conditions that indicate something unexpected has occurred

* error: a fatal condition; we cannot move forward with the code

* warning: an unexpected condition; we can move on but you should know about it

* message: something notable has occurred but you're probably fine

In your *own* functions, you may decide to produce an error, warnning, or message when appropriate.

What do you if someone *else's* function produces a condition but you want to handle it differently?

# Errors

Sometimes it's okay for errors to occur, because you can find a way around them or ignore them. In those cases, we need a way to tell R to ignore the error (or at least do something different).

```{r}
f <- function(x) {
        y <- x + 1
        y
}
f(1)
```

But what about...
```{r,error=TRUE}
f("1")
```

# `try()`

The `try()` function is a simple way to catch an error without necessarily stopping the execution of a function.

```{r}
bad_func <- function(x) {
        y <- x + 1
        y
}
a <- try(bad_func(1))  ## OK
b <- try(bad_func("1"))
```

# `try()`

What does `try()` return in case there is an error?

```{r}
b
```

This is an object of class `try-error`, which is something you can check for.

```{r}
inherits(b, "try-error")
```

# Using `try()`

Often, when using `for` loops, most of the inputs will be okay but some may be problematic. In these scenarios you want to finish the loop and deal with the problem later.

This loop doesn't finish.
```{r, error=TRUE}
input <- list(43, "a", 3)
results <- list(length(input))
for(i in seq_along(input)) {
        results[[i]] <- bad_func(input[[i]])
}
```

# Using `try()`

This loop will finish regardless of the error

```{r}
input <- list(43, "a", 3)
results <- list(length(input))
for(i in seq_along(input)) {
        results[[i]] <- try({
                bad_func(input[[i]])
        })
}
```

# Using `try()`

The result is

```{r}
results
```


# Using `try()`

Now we can deal with the errors and just treat them as `NA` values

```{r}
for(i in seq_along(results)) {
        if(inherits(results[[i]], "try-error")) {
                results[[i]] <- NA
        }
}
results
```










